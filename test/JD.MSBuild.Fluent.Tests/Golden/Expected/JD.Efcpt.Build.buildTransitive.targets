<Project>

  <!--
    Late-evaluated property overrides.
    These are set here in the targets file (not props) because the targets file
    is imported AFTER the project file, allowing us to see the final property values.
    Props files are imported BEFORE the project file, so they see SDK defaults instead.
  -->
  <PropertyGroup>
    <!-- Derive UseNullableReferenceTypes from project's Nullable setting for zero-config scenarios -->
    <EfcptConfigUseNullableReferenceTypes Condition="'$(EfcptConfigUseNullableReferenceTypes)'=='' and ('$(Nullable)'=='enable' or '$(Nullable)'=='Enable')">true</EfcptConfigUseNullableReferenceTypes>
    <EfcptConfigUseNullableReferenceTypes Condition="'$(EfcptConfigUseNullableReferenceTypes)'=='' and '$(Nullable)'!=''">false</EfcptConfigUseNullableReferenceTypes>
  </PropertyGroup>

  <!--
    SQL Project Detection: Detect if this is a SQL database project (not an EF Core consumer project).

    Detection logic (in priority order):
    1. Check if project file Sdk attribute references Microsoft.Build.Sql or MSBuild.Sdk.SqlProj
    2. Fall back to MSBuild properties ($(SqlServerVersion) or $(DSP)) for legacy SSDT projects

    This must be in the targets file (not props) because SDK properties like SqlServerVersion
    are not available when props files are evaluated.
  -->
  <Target Name="_EfcptDetectSqlProject" BeforeTargets="BeforeBuild;BeforeRebuild">
    <DetectSqlProject
        ProjectPath="$(MSBuildProjectFullPath)"
        SqlServerVersion="$(SqlServerVersion)"
        DSP="$(DSP)">
      <Output TaskParameter="IsSqlProject" PropertyName="_EfcptIsSqlProject" />
    </DetectSqlProject>
    
    <!-- Defensive: ensure the property is always set, even if the task encounters an unexpected scenario -->
    <PropertyGroup>
      <_EfcptIsSqlProject Condition="'$(_EfcptIsSqlProject)'==''">false</_EfcptIsSqlProject>
    </PropertyGroup>
  </Target>

  <!--
    Determine the correct task assembly path based on MSBuild runtime and version.

    JD.Efcpt.Build supports both:
    - .NET Core MSBuild (MSBuildRuntimeType='Core') - Visual Studio 2019+ SDK-style projects
    - .NET Framework MSBuild (MSBuildRuntimeType='Full') - Visual Studio with Framework MSBuild

    The task assembly is multi-targeted:
    - net472: For .NET Framework MSBuild
    - net8.0/net9.0/net10.0: For .NET Core MSBuild (version-matched)
  -->
  <PropertyGroup>
    <!--
      For .NET Core MSBuild, select task assembly based on MSBuild version:
      - MSBuild 18.0+ (VS 2026, .NET 10.0.1xx SDK) -> net10.0
      - MSBuild 17.14+ (VS 2022 17.14+, min VS for .NET 10 SDK) -> net10.0
      - MSBuild 17.12+ (VS 2022 17.12+, .NET 9.0.1xx SDK) -> net9.0
      - MSBuild 17.8+ (VS 2022 17.8+, .NET 8.0.1xx SDK) -> net8.0
      
      Version mapping reference:
      https://learn.microsoft.com/en-us/dotnet/core/porting/versioning-sdk-msbuild-vs
    -->
    <_EfcptTasksFolder Condition="'$(MSBuildRuntimeType)' == 'Core' and $([MSBuild]::VersionGreaterThanOrEquals('$(MSBuildVersion)', '18.0'))">net10.0</_EfcptTasksFolder>
    <_EfcptTasksFolder Condition="'$(_EfcptTasksFolder)' == '' and '$(MSBuildRuntimeType)' == 'Core' and $([MSBuild]::VersionGreaterThanOrEquals('$(MSBuildVersion)', '17.14'))">net10.0</_EfcptTasksFolder>
    <_EfcptTasksFolder Condition="'$(_EfcptTasksFolder)' == '' and '$(MSBuildRuntimeType)' == 'Core' and $([MSBuild]::VersionGreaterThanOrEquals('$(MSBuildVersion)', '17.12'))">net9.0</_EfcptTasksFolder>
    <_EfcptTasksFolder Condition="'$(_EfcptTasksFolder)' == '' and '$(MSBuildRuntimeType)' == 'Core'">net8.0</_EfcptTasksFolder>

    <!-- For .NET Framework MSBuild (Visual Studio with Framework MSBuild), use net472 -->
    <_EfcptTasksFolder Condition="'$(_EfcptTasksFolder)' == ''">net472</_EfcptTasksFolder>

    <!-- Primary path: NuGet package location -->
    <_EfcptTaskAssembly>$(MSBuildThisFileDirectory)..\tasks\$(_EfcptTasksFolder)\JD.Efcpt.Build.Tasks.dll</_EfcptTaskAssembly>

    <!-- Fallback path: Local development (when building from source) -->
    <_EfcptTaskAssembly Condition="!Exists('$(_EfcptTaskAssembly)')">$(MSBuildThisFileDirectory)..\..\JD.Efcpt.Build.Tasks\bin\$(Configuration)\$(_EfcptTasksFolder)\JD.Efcpt.Build.Tasks.dll</_EfcptTaskAssembly>
    <_EfcptTaskAssembly Condition="!Exists('$(_EfcptTaskAssembly)') and '$(Configuration)' == ''">$(MSBuildThisFileDirectory)..\..\JD.Efcpt.Build.Tasks\bin\Debug\$(_EfcptTasksFolder)\JD.Efcpt.Build.Tasks.dll</_EfcptTaskAssembly>
  </PropertyGroup>

  <!-- Diagnostic output for task assembly selection (when EfcptLogVerbosity=detailed) -->
  <Target Name="_EfcptLogTaskAssemblyInfo" BeforeTargets="EfcptResolveInputs;EfcptResolveInputsForDirectDacpac" Condition="'$(EfcptEnabled)' == 'true' and '$(EfcptLogVerbosity)' == 'detailed'">
    <Message Text="EFCPT Task Assembly Selection:" Importance="high" />
    <Message Text="  MSBuildRuntimeType: $(MSBuildRuntimeType)" Importance="high" />
    <Message Text="  MSBuildVersion: $(MSBuildVersion)" Importance="high" />
    <Message Text="  Selected TasksFolder: $(_EfcptTasksFolder)" Importance="high" />
    <Message Text="  TaskAssembly Path: $(_EfcptTaskAssembly)" Importance="high" />
    <Message Text="  TaskAssembly Exists: $([System.IO.File]::Exists('$(_EfcptTaskAssembly)'))" Importance="high" />
  </Target>

  <!--
    Register MSBuild tasks.
    The task assembly is multi-targeted (net472 + net8.0+) so it loads natively
    on both .NET Framework MSBuild and .NET Core MSBuild.
  -->
  <UsingTask TaskName="JD.Efcpt.Build.Tasks.ResolveSqlProjAndInputs"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.EnsureDacpacBuilt"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.StageEfcptInputs"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.ComputeFingerprint"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.RunEfcpt"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.RenameGeneratedFiles"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.QuerySchemaMetadata"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.ApplyConfigOverrides"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.ResolveDbContextName"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.SerializeConfigProperties"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.CheckSdkVersion"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.RunSqlPackage"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.AddSqlFileWarnings"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.DetectSqlProject"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.InitializeBuildProfiling"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <UsingTask TaskName="JD.Efcpt.Build.Tasks.FinalizeBuildProfiling"
             AssemblyFile="$(_EfcptTaskAssembly)" />

  <!--
    Build Profiling: Initialize profiling at the start of the build pipeline.
    This target runs early to ensure the profiler is available for all subsequent tasks.
  -->
  <Target Name="_EfcptInitializeProfiling"
          BeforeTargets="_EfcptDetectSqlProject"
          Condition="'$(EfcptEnabled)' == 'true'">
    <InitializeBuildProfiling
        EnableProfiling="$(EfcptEnableProfiling)"
        ProjectPath="$(MSBuildProjectFullPath)"
        ProjectName="$(MSBuildProjectName)"
        TargetFramework="$(TargetFramework)"
        Configuration="$(Configuration)"
        ConfigPath="$(_EfcptResolvedConfig)"
        RenamingPath="$(_EfcptResolvedRenaming)"
        TemplateDir="$(_EfcptResolvedTemplateDir)"
        SqlProjectPath="$(_EfcptSqlProj)"
        DacpacPath="$(_EfcptDacpacPath)"
        Provider="$(EfcptProvider)" />
  </Target>

  <!--
    SDK Version Check: Warns users when a newer SDK version is available.
    Opt-in via EfcptCheckForUpdates=true. Results are cached for 24 hours.
  -->
  <Target Name="_EfcptCheckForUpdates"
          BeforeTargets="Build"
          Condition="'$(EfcptCheckForUpdates)' == 'true' and '$(EfcptSdkVersion)' != ''">
    <CheckSdkVersion
        CurrentVersion="$(EfcptSdkVersion)"
        PackageId="JD.Efcpt.Sdk"
        CacheHours="$(EfcptUpdateCheckCacheHours)"
        ForceCheck="$(EfcptForceUpdateCheck)"
        WarningLevel="$(EfcptSdkVersionWarningLevel)">
      <Output TaskParameter="LatestVersion" PropertyName="_EfcptLatestVersion" />
      <Output TaskParameter="UpdateAvailable" PropertyName="_EfcptUpdateAvailable" />
    </CheckSdkVersion>
  </Target>

  <!--
    ========================================================================
    SQL Project Generation Pipeline: Extract database schema to SQL scripts
    ========================================================================
    When JD.Efcpt.Build is referenced within a SQL project (Microsoft.Build.Sql or 
    MSBuild.Sdk.SqlProj), this pipeline automatically extracts the database schema 
    into individual SQL script files within that SQL project.
    
    Detection is automatic based on SDK type - no configuration needed.
    
    This enables the workflow: 
    Database → SQL Scripts (in SQL Project) → Build to DACPAC → EF Core Models (in DataAccess Project)
    
    Lifecycle hooks:
    - BeforeSqlProjGeneration: Custom target that runs before extraction
    - AfterSqlProjGeneration: Custom target that runs after SQL scripts are generated
    - BeforeEfcptGeneration: Custom target that runs before EF Core generation
    - AfterEfcptGeneration: Custom target that runs after EF Core generation
  -->

  <!-- Lifecycle hook: BeforeSqlProjGeneration -->
  <Target Name="BeforeSqlProjGeneration"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' == 'true'" />

  <!-- Query database schema for fingerprinting -->
  <Target Name="EfcptQueryDatabaseSchemaForSqlProj"
          DependsOnTargets="BeforeSqlProjGeneration"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' == 'true'">
    <Error Condition="'$(EfcptConnectionString)' == '' and '$(EfcptAppSettings)' == '' and '$(EfcptAppConfig)' == ''"
           Text="SqlProj generation requires a connection string. Set EfcptConnectionString, EfcptAppSettings, or EfcptAppConfig." />
    
    <Message Text="Querying database schema for fingerprinting..." Importance="high" />
    
    <QuerySchemaMetadata
        ConnectionString="$(EfcptConnectionString)"
        OutputDir="$(EfcptOutput)"
        Provider="$(EfcptProvider)"
        LogVerbosity="$(EfcptLogVerbosity)">
      <Output TaskParameter="SchemaFingerprint" PropertyName="_EfcptSchemaFingerprint" />
    </QuerySchemaMetadata>
    
    <Message Text="Database schema fingerprint: $(_EfcptSchemaFingerprint)" Importance="normal" />
  </Target>

  <!-- Extract database schema to SQL scripts using sqlpackage -->
  <Target Name="EfcptExtractDatabaseSchemaToScripts"
          DependsOnTargets="EfcptQueryDatabaseSchemaForSqlProj"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' == 'true'">
    <PropertyGroup>
      <!-- Extract directly to the SQL project directory -->
      <_EfcptScriptsDir>$(EfcptSqlScriptsDir)</_EfcptScriptsDir>
    </PropertyGroup>
    
    <Message Text="Extracting database schema to SQL scripts in SQL project: $(_EfcptScriptsDir)" Importance="high" />
    
    <!-- Remove existing generated scripts to ensure clean generation -->
    <!-- Only remove specific patterns to avoid deleting user scripts -->
    <ItemGroup>
      <_EfcptGeneratedScripts Include="$(_EfcptScriptsDir)**\*.sql" />
    </ItemGroup>
    <Delete Files="@(_EfcptGeneratedScripts)" Condition="'@(_EfcptGeneratedScripts)' != ''" />
    
    <RunSqlPackage
        ToolVersion="$(EfcptSqlPackageToolVersion)"
        ToolRestore="$(EfcptSqlPackageToolRestore)"
        ToolPath="$(EfcptSqlPackageToolPath)"
        DotNetExe="$(EfcptDotNetExe)"
        WorkingDirectory="$(EfcptOutput)"
        ConnectionString="$(EfcptConnectionString)"
        TargetDirectory="$(_EfcptScriptsDir)"
        ExtractTarget="SchemaObjectType"
        TargetFramework="$(TargetFramework)"
        LogVerbosity="$(EfcptLogVerbosity)">
      <Output TaskParameter="ExtractedPath" PropertyName="_EfcptExtractedScriptsPath" />
    </RunSqlPackage>
    
    <Message Text="Extracted SQL scripts to: $(_EfcptExtractedScriptsPath)" Importance="high" />
  </Target>

  <!-- Add auto-generation warnings to SQL files -->
  <Target Name="EfcptAddSqlFileWarnings"
          DependsOnTargets="EfcptExtractDatabaseSchemaToScripts"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' == 'true'">
    <Message Text="Adding auto-generation warnings to SQL files..." Importance="high" />
    
    <!-- Get database name from connection string for the warning header -->
    <PropertyGroup>
      <_EfcptDatabaseName Condition="$(EfcptConnectionString.Contains('Database='))">$([System.Text.RegularExpressions.Regex]::Match($(EfcptConnectionString), 'Database\s*=\s*\"?([^;"]+)\"?').Groups[1].Value)</_EfcptDatabaseName>
      <_EfcptDatabaseName Condition="$(EfcptConnectionString.Contains('Initial Catalog='))">$([System.Text.RegularExpressions.Regex]::Match($(EfcptConnectionString), 'Initial Catalog\s*=\s*\"?([^;"]+)\"?').Groups[1].Value)</_EfcptDatabaseName>
    </PropertyGroup>
    
    <AddSqlFileWarnings
        ScriptsDirectory="$(_EfcptScriptsDir)"
        DatabaseName="$(_EfcptDatabaseName)"
        LogVerbosity="$(EfcptLogVerbosity)" />
  </Target>

  <!-- Lifecycle hook: AfterSqlProjGeneration -->
  <!-- This runs after SQL scripts are generated in the SQL project -->
  <!-- The SQL project will build normally and create its DACPAC -->
  <!-- DataAccess projects that reference this SQL project will wait for this to complete -->
  <Target Name="AfterSqlProjGeneration"
          DependsOnTargets="EfcptAddSqlFileWarnings"
          BeforeTargets="Build"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' == 'true'">
    <Message Text="_EfcptIsSqlProject: $(_EfcptIsSqlProject)" Importance="high" />
    <Message Text="SQL script generation complete. SQL project will build to DACPAC." Importance="high" />
  </Target>

  <!-- Main pipeline -->
  <!-- When NOT in a SQL project, resolve inputs normally -->
  <Target Name="EfcptResolveInputs"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' != 'true' and '$(EfcptDacpac)' == ''">
    <ResolveSqlProjAndInputs
        ProjectFullPath="$(MSBuildProjectFullPath)"
        ProjectDirectory="$(MSBuildProjectDirectory)"
        Configuration="$(Configuration)"
        ProjectReferences="@(ProjectReference)"
        SqlProjOverride="$(EfcptSqlProj)"
        ConfigOverride="$(EfcptConfig)"
        RenamingOverride="$(EfcptRenaming)"
        TemplateDirOverride="$(EfcptTemplateDir)"
        SolutionDir="$(EfcptSolutionDir)"
        SolutionPath="$(EfcptSolutionPath)"
        ProbeSolutionDir="$(EfcptProbeSolutionDir)"
        OutputDir="$(EfcptOutput)"
        DefaultsRoot="$(MSBuildThisFileDirectory)Defaults"
        DumpResolvedInputs="$(EfcptDumpResolvedInputs)"
        EfcptConnectionString="$(EfcptConnectionString)"
        EfcptAppSettings="$(EfcptAppSettings)"
        EfcptAppConfig="$(EfcptAppConfig)"
        EfcptConnectionStringName="$(EfcptConnectionStringName)"
        AutoDetectWarningLevel="$(EfcptAutoDetectWarningLevel)">
      <Output TaskParameter="SqlProjPath" PropertyName="_EfcptSqlProj" />
      <Output TaskParameter="ResolvedConfigPath" PropertyName="_EfcptResolvedConfig" />
      <Output TaskParameter="ResolvedRenamingPath" PropertyName="_EfcptResolvedRenaming" />
      <Output TaskParameter="ResolvedTemplateDir" PropertyName="_EfcptResolvedTemplateDir" />
      <Output TaskParameter="ResolvedConnectionString" PropertyName="_EfcptResolvedConnectionString" />
      <Output TaskParameter="UseConnectionString" PropertyName="_EfcptUseConnectionString" />
      <Output TaskParameter="IsUsingDefaultConfig" PropertyName="_EfcptIsUsingDefaultConfig" />
    </ResolveSqlProjAndInputs>
  </Target>

  <!-- Simplified resolution for direct DACPAC mode (bypass SQL project detection) -->
  <Target Name="EfcptResolveInputsForDirectDacpac"
          Condition="'$(EfcptEnabled)' == 'true' and '$(EfcptDacpac)' != ''">
    <PropertyGroup>
      <_EfcptResolvedConfig Condition="Exists('$(MSBuildProjectDirectory)\$(EfcptConfig)')">$(MSBuildProjectDirectory)\$(EfcptConfig)</_EfcptResolvedConfig>
      <_EfcptResolvedConfig Condition="'$(_EfcptResolvedConfig)' == ''">$(MSBuildThisFileDirectory)Defaults\efcpt-config.json</_EfcptResolvedConfig>
      <_EfcptResolvedRenaming Condition="Exists('$(MSBuildProjectDirectory)\$(EfcptRenaming)')">$(MSBuildProjectDirectory)\$(EfcptRenaming)</_EfcptResolvedRenaming>
      <_EfcptResolvedRenaming Condition="'$(_EfcptResolvedRenaming)' == ''">$(MSBuildThisFileDirectory)Defaults\efcpt.renaming.json</_EfcptResolvedRenaming>
      <_EfcptResolvedTemplateDir Condition="Exists('$(MSBuildProjectDirectory)\$(EfcptTemplateDir)')">$(MSBuildProjectDirectory)\$(EfcptTemplateDir)</_EfcptResolvedTemplateDir>
      <_EfcptResolvedTemplateDir Condition="'$(_EfcptResolvedTemplateDir)' == ''">$(MSBuildThisFileDirectory)Defaults\Template</_EfcptResolvedTemplateDir>
      <_EfcptIsUsingDefaultConfig>true</_EfcptIsUsingDefaultConfig>
      <_EfcptUseConnectionString>false</_EfcptUseConnectionString>
    </PropertyGroup>
    <MakeDir Directories="$(EfcptOutput)" />
  </Target>

  <Target Name="EfcptQuerySchemaMetadata"
          AfterTargets="EfcptResolveInputs"
          BeforeTargets="EfcptStageInputs"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptUseConnectionString)' == 'true'">
    <QuerySchemaMetadata
        ConnectionString="$(_EfcptResolvedConnectionString)"
        OutputDir="$(EfcptOutput)"
        Provider="$(EfcptProvider)"
        LogVerbosity="$(EfcptLogVerbosity)">
      <Output TaskParameter="SchemaFingerprint" PropertyName="_EfcptSchemaFingerprint" />
    </QuerySchemaMetadata>
  </Target>

  <Target Name="EfcptUseDirectDacpac"
          DependsOnTargets="EfcptResolveInputs;EfcptResolveInputsForDirectDacpac"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptUseConnectionString)' != 'true' and '$(EfcptDacpac)' != ''">
    <PropertyGroup>
      <!-- Use Combine+GetFullPath to resolve non-rooted EfcptDacpac paths relative to $(MSBuildProjectDirectory) -->
      <_EfcptDacpacPath Condition="$([System.IO.Path]::IsPathRooted('$(EfcptDacpac)'))">$(EfcptDacpac)</_EfcptDacpacPath>
      <_EfcptDacpacPath Condition="!$([System.IO.Path]::IsPathRooted('$(EfcptDacpac)'))">$([System.IO.Path]::GetFullPath($([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(EfcptDacpac)'))))</_EfcptDacpacPath>
      <_EfcptUseDirectDacpac>true</_EfcptUseDirectDacpac>
    </PropertyGroup>
    <Error Condition="!Exists('$(_EfcptDacpacPath)')"
           Text="EfcptDacpac was specified but the file does not exist: $(_EfcptDacpacPath)" />
    <Message Text="Using pre-built DACPAC: $(_EfcptDacpacPath)" Importance="high" />
  </Target>

  <!--
    Build the SQL project using MSBuild's native task to ensure proper dependency ordering.
    This prevents race conditions when MSBuild runs in parallel mode - the SQL project
    build will complete before any targets that depend on this one can proceed.
    Note: The mode-specific condition (checking connection string vs dacpac mode) is on the
    MSBuild task, not the target, because target conditions evaluate before DependsOnTargets
    complete. The target's EfcptEnabled condition is a simple enable/disable check.
  -->
  <Target Name="EfcptBuildSqlProj"
          DependsOnTargets="EfcptResolveInputs;EfcptUseDirectDacpac"
          Condition="'$(EfcptEnabled)' == 'true'">
    <Message Condition="'$(_EfcptUseConnectionString)' != 'true' and '$(_EfcptUseDirectDacpac)' != 'true' and '$(_EfcptSqlProj)' != ''"
             Text="Building SQL project: $(_EfcptSqlProj)" Importance="normal" />
    <MSBuild Condition="'$(_EfcptUseConnectionString)' != 'true' and '$(_EfcptUseDirectDacpac)' != 'true' and '$(_EfcptSqlProj)' != ''"
             Projects="$(_EfcptSqlProj)"
             Targets="Build"
             Properties="Configuration=$(Configuration)"
             BuildInParallel="false" />
  </Target>

  <!--
    EfcptEnsureDacpac: Build dacpac if needed (not in connection string mode).
    Note: The condition check happens INSIDE the target (not on the target itself)
    because target conditions are evaluated before DependsOnTargets run.
  -->
  <Target Name="EfcptEnsureDacpac"
          DependsOnTargets="EfcptResolveInputs;EfcptUseDirectDacpac;EfcptBuildSqlProj"
          Condition="'$(EfcptEnabled)' == 'true'">
    <!-- Only run the dacpac task when NOT in connection string mode, NOT using direct dacpac, and NOT in a SQL project -->
    <EnsureDacpacBuilt
        Condition="'$(_EfcptUseConnectionString)' != 'true' and '$(_EfcptUseDirectDacpac)' != 'true' and '$(_EfcptIsSqlProject)' != 'true'"
        SqlProjPath="$(_EfcptSqlProj)"
        Configuration="$(Configuration)"
        MsBuildExe="$(MSBuildBinPath)msbuild.exe"
        DotNetExe="$(EfcptDotNetExe)"
        LogVerbosity="$(EfcptLogVerbosity)">
      <Output TaskParameter="DacpacPath" PropertyName="_EfcptDacpacPath" />
    </EnsureDacpacBuilt>
  </Target>

  <!--
    Resolve DbContext name from SQL project, DACPAC, or connection string.
    This runs after DACPAC is ensured/resolved but before staging to allow
    the resolved name to be used as an override in ApplyConfigOverrides.
  -->
  <Target Name="EfcptResolveDbContextName"
          DependsOnTargets="EfcptResolveInputs;EfcptEnsureDacpac;EfcptUseDirectDacpac"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' != 'true'">
    <ResolveDbContextName
        ExplicitDbContextName="$(EfcptConfigDbContextName)"
        SqlProjPath="$(_EfcptSqlProj)"
        DacpacPath="$(_EfcptDacpacPath)"
        ConnectionString="$(_EfcptResolvedConnectionString)"
        UseConnectionStringMode="$(_EfcptUseConnectionString)"
        LogVerbosity="$(EfcptLogVerbosity)">
      <Output TaskParameter="ResolvedDbContextName" PropertyName="_EfcptResolvedDbContextName" />
    </ResolveDbContextName>
    <!-- Set the config property to the resolved name if not explicitly set by user -->
    <PropertyGroup>
      <EfcptConfigDbContextName Condition="'$(EfcptConfigDbContextName)' == ''">$(_EfcptResolvedDbContextName)</EfcptConfigDbContextName>
    </PropertyGroup>
  </Target>

  <Target Name="EfcptStageInputs"
          DependsOnTargets="EfcptResolveInputs;EfcptEnsureDacpac;EfcptUseDirectDacpac;EfcptResolveDbContextName"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' != 'true'">
    <StageEfcptInputs
        OutputDir="$(EfcptOutput)"
        ProjectDirectory="$(MSBuildProjectDirectory)"
        ConfigPath="$(_EfcptResolvedConfig)"
        RenamingPath="$(_EfcptResolvedRenaming)"
        TemplateDir="$(_EfcptResolvedTemplateDir)"
        TemplateOutputDir="$(EfcptGeneratedDir)"
        TargetFramework="$(TargetFramework)"
        LogVerbosity="$(EfcptLogVerbosity)">
      <Output TaskParameter="StagedConfigPath" PropertyName="_EfcptStagedConfig" />
      <Output TaskParameter="StagedRenamingPath" PropertyName="_EfcptStagedRenaming" />
      <Output TaskParameter="StagedTemplateDir" PropertyName="_EfcptStagedTemplateDir" />
    </StageEfcptInputs>
  </Target>

  <!--
    Apply MSBuild property overrides to the staged efcpt-config.json file.
    Runs after staging but before fingerprinting to ensure overrides are included in the hash.
  -->
  <Target Name="EfcptApplyConfigOverrides"
          DependsOnTargets="EfcptStageInputs"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' != 'true'">
    <ApplyConfigOverrides
        StagedConfigPath="$(_EfcptStagedConfig)"
        ApplyOverrides="$(EfcptApplyMsBuildOverrides)"
        IsUsingDefaultConfig="$(_EfcptIsUsingDefaultConfig)"
        LogVerbosity="$(EfcptLogVerbosity)"
        RootNamespace="$(EfcptConfigRootNamespace)"
        DbContextName="$(EfcptConfigDbContextName)"
        DbContextNamespace="$(EfcptConfigDbContextNamespace)"
        ModelNamespace="$(EfcptConfigModelNamespace)"
        OutputPath="$(EfcptConfigOutputPath)"
        DbContextOutputPath="$(EfcptConfigDbContextOutputPath)"
        SplitDbContext="$(EfcptConfigSplitDbContext)"
        UseSchemaFolders="$(EfcptConfigUseSchemaFolders)"
        UseSchemaNamespaces="$(EfcptConfigUseSchemaNamespaces)"
        EnableOnConfiguring="$(EfcptConfigEnableOnConfiguring)"
        GenerationType="$(EfcptConfigGenerationType)"
        UseDatabaseNames="$(EfcptConfigUseDatabaseNames)"
        UseDataAnnotations="$(EfcptConfigUseDataAnnotations)"
        UseNullableReferenceTypes="$(EfcptConfigUseNullableReferenceTypes)"
        UseInflector="$(EfcptConfigUseInflector)"
        UseLegacyInflector="$(EfcptConfigUseLegacyInflector)"
        UseManyToManyEntity="$(EfcptConfigUseManyToManyEntity)"
        UseT4="$(EfcptConfigUseT4)"
        UseT4Split="$(EfcptConfigUseT4Split)"
        RemoveDefaultSqlFromBool="$(EfcptConfigRemoveDefaultSqlFromBool)"
        SoftDeleteObsoleteFiles="$(EfcptConfigSoftDeleteObsoleteFiles)"
        DiscoverMultipleResultSets="$(EfcptConfigDiscoverMultipleResultSets)"
        UseAlternateResultSetDiscovery="$(EfcptConfigUseAlternateResultSetDiscovery)"
        T4TemplatePath="$(EfcptConfigT4TemplatePath)"
        UseNoNavigations="$(EfcptConfigUseNoNavigations)"
        MergeDacpacs="$(EfcptConfigMergeDacpacs)"
        RefreshObjectLists="$(EfcptConfigRefreshObjectLists)"
        GenerateMermaidDiagram="$(EfcptConfigGenerateMermaidDiagram)"
        UseDecimalAnnotationForSprocs="$(EfcptConfigUseDecimalAnnotationForSprocs)"
        UsePrefixNavigationNaming="$(EfcptConfigUsePrefixNavigationNaming)"
        UseDatabaseNamesForRoutines="$(EfcptConfigUseDatabaseNamesForRoutines)"
        UseInternalAccessForRoutines="$(EfcptConfigUseInternalAccessForRoutines)"
        UseDateOnlyTimeOnly="$(EfcptConfigUseDateOnlyTimeOnly)"
        UseHierarchyId="$(EfcptConfigUseHierarchyId)"
        UseSpatial="$(EfcptConfigUseSpatial)"
        UseNodaTime="$(EfcptConfigUseNodaTime)"
        PreserveCasingWithRegex="$(EfcptConfigPreserveCasingWithRegex)" />
  </Target>

  <!--
    Serialize MSBuild config property overrides to a JSON string for fingerprinting.
    This ensures that changes to EfcptConfig* properties trigger regeneration.
  -->
  <Target Name="EfcptSerializeConfigProperties"
          DependsOnTargets="EfcptApplyConfigOverrides"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' != 'true'">
    <SerializeConfigProperties
        RootNamespace="$(EfcptConfigRootNamespace)"
        DbContextName="$(EfcptConfigDbContextName)"
        DbContextNamespace="$(EfcptConfigDbContextNamespace)"
        ModelNamespace="$(EfcptConfigModelNamespace)"
        OutputPath="$(EfcptConfigOutputPath)"
        DbContextOutputPath="$(EfcptConfigDbContextOutputPath)"
        SplitDbContext="$(EfcptConfigSplitDbContext)"
        UseSchemaFolders="$(EfcptConfigUseSchemaFolders)"
        UseSchemaNamespaces="$(EfcptConfigUseSchemaNamespaces)"
        EnableOnConfiguring="$(EfcptConfigEnableOnConfiguring)"
        GenerationType="$(EfcptConfigGenerationType)"
        UseDatabaseNames="$(EfcptConfigUseDatabaseNames)"
        UseDataAnnotations="$(EfcptConfigUseDataAnnotations)"
        UseNullableReferenceTypes="$(EfcptConfigUseNullableReferenceTypes)"
        UseInflector="$(EfcptConfigUseInflector)"
        UseLegacyInflector="$(EfcptConfigUseLegacyInflector)"
        UseManyToManyEntity="$(EfcptConfigUseManyToManyEntity)"
        UseT4="$(EfcptConfigUseT4)"
        UseT4Split="$(EfcptConfigUseT4Split)"
        RemoveDefaultSqlFromBool="$(EfcptConfigRemoveDefaultSqlFromBool)"
        SoftDeleteObsoleteFiles="$(EfcptConfigSoftDeleteObsoleteFiles)"
        DiscoverMultipleResultSets="$(EfcptConfigDiscoverMultipleResultSets)"
        UseAlternateResultSetDiscovery="$(EfcptConfigUseAlternateResultSetDiscovery)"
        T4TemplatePath="$(EfcptConfigT4TemplatePath)"
        UseNoNavigations="$(EfcptConfigUseNoNavigations)"
        MergeDacpacs="$(EfcptConfigMergeDacpacs)"
        RefreshObjectLists="$(EfcptConfigRefreshObjectLists)"
        GenerateMermaidDiagram="$(EfcptConfigGenerateMermaidDiagram)"
        UseDecimalAnnotationForSprocs="$(EfcptConfigUseDecimalAnnotationForSprocs)"
        UsePrefixNavigationNaming="$(EfcptConfigUsePrefixNavigationNaming)"
        UseDatabaseNamesForRoutines="$(EfcptConfigUseDatabaseNamesForRoutines)"
        UseInternalAccessForRoutines="$(EfcptConfigUseInternalAccessForRoutines)"
        UseDateOnlyTimeOnly="$(EfcptConfigUseDateOnlyTimeOnly)"
        UseHierarchyId="$(EfcptConfigUseHierarchyId)"
        UseSpatial="$(EfcptConfigUseSpatial)"
        UseNodaTime="$(EfcptConfigUseNodaTime)"
        PreserveCasingWithRegex="$(EfcptConfigPreserveCasingWithRegex)">
      <Output TaskParameter="SerializedProperties" PropertyName="_EfcptSerializedConfigProperties" />
    </SerializeConfigProperties>
  </Target>

  <Target Name="EfcptComputeFingerprint"
          DependsOnTargets="EfcptSerializeConfigProperties"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' != 'true'">
    <ComputeFingerprint
        DacpacPath="$(_EfcptDacpacPath)"
        SchemaFingerprint="$(_EfcptSchemaFingerprint)"
        UseConnectionStringMode="$(_EfcptUseConnectionString)"
        ConfigPath="$(_EfcptStagedConfig)"
        RenamingPath="$(_EfcptStagedRenaming)"
        TemplateDir="$(_EfcptStagedTemplateDir)"
        FingerprintFile="$(EfcptFingerprintFile)"
        ToolVersion="$(EfcptToolVersion)"
        GeneratedDir="$(EfcptGeneratedDir)"
        DetectGeneratedFileChanges="$(EfcptDetectGeneratedFileChanges)"
        ConfigPropertyOverrides="$(_EfcptSerializedConfigProperties)"
        LogVerbosity="$(EfcptLogVerbosity)">
      <Output TaskParameter="Fingerprint" PropertyName="_EfcptFingerprint" />
      <Output TaskParameter="HasChanged" PropertyName="_EfcptFingerprintChanged" />
    </ComputeFingerprint>
  </Target>

  <!-- Lifecycle hook: BeforeEfcptGeneration -->
  <Target Name="BeforeEfcptGeneration"
          DependsOnTargets="EfcptComputeFingerprint"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' != 'true'" />

  <Target Name="EfcptGenerateModels"
          DependsOnTargets="BeforeEfcptGeneration"
          BeforeTargets="CoreCompile"
          Inputs="$(_EfcptDacpacPath);$(_EfcptStagedConfig);$(_EfcptStagedRenaming)"
          Outputs="$(EfcptStampFile)"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' != 'true' and ('$(_EfcptFingerprintChanged)' == 'true' or !Exists('$(EfcptStampFile)'))">
    <MakeDir Directories="$(EfcptGeneratedDir)" />
    <RunEfcpt
        ToolMode="$(EfcptToolMode)"
        ToolPackageId="$(EfcptToolPackageId)"
        ToolVersion="$(EfcptToolVersion)"
        ToolRestore="$(EfcptToolRestore)"
        ToolCommand="$(EfcptToolCommand)"
        ToolPath="$(EfcptToolPath)"
        DotNetExe="$(EfcptDotNetExe)"
        WorkingDirectory="$(EfcptOutput)"
        DacpacPath="$(_EfcptDacpacPath)"
        ConnectionString="$(_EfcptResolvedConnectionString)"
        UseConnectionStringMode="$(_EfcptUseConnectionString)"
        Provider="$(EfcptProvider)"
        ConfigPath="$(_EfcptStagedConfig)"
        RenamingPath="$(_EfcptStagedRenaming)"
        TemplateDir="$(_EfcptStagedTemplateDir)"
        OutputDir="$(EfcptGeneratedDir)"
        TargetFramework="$(TargetFramework)"
        ProjectPath="$(MSBuildProjectFullPath)"
        LogVerbosity="$(EfcptLogVerbosity)" />
    <RenameGeneratedFiles
        GeneratedDir="$(EfcptGeneratedDir)"
        LogVerbosity="$(EfcptLogVerbosity)" />
    <WriteLinesToFile File="$(EfcptStampFile)" Lines="$(_EfcptFingerprint)" Overwrite="true" />
  </Target>

  <!-- Lifecycle hook: AfterEfcptGeneration -->
  <Target Name="AfterEfcptGeneration"
          AfterTargets="EfcptGenerateModels"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' != 'true'" />

  <!--
    ========================================================================
    Split Outputs: Separate Models project from Data project
    ========================================================================
    When EfcptSplitOutputs=true, the Models project is the primary project
    that runs efcpt and generates all files. Entity models stay in Models,
    while DbContext and configurations are copied to the Data project.

    This approach works because Data depends on Models, so Models builds
    first and generates the code before Data needs the types.
  -->

  <!--
    Validate split outputs configuration and resolve Data project path.
    Ensures the Data project exists and is properly configured.
  -->
  <Target Name="EfcptValidateSplitOutputs"
          DependsOnTargets="EfcptGenerateModels"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' != 'true' and '$(EfcptSplitOutputs)' == 'true'">

    <!-- Resolve Data project path -->
    <!-- Use Combine+GetFullPath to resolve non-rooted EfcptDataProject paths relative to $(MSBuildProjectDirectory) -->
    <PropertyGroup>
      <_EfcptDataProjectPath Condition="'$(EfcptDataProject)' != '' and $([System.IO.Path]::IsPathRooted('$(EfcptDataProject)'))">$(EfcptDataProject)</_EfcptDataProjectPath>
      <_EfcptDataProjectPath Condition="'$(EfcptDataProject)' != '' and !$([System.IO.Path]::IsPathRooted('$(EfcptDataProject)'))">$([System.IO.Path]::GetFullPath($([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(EfcptDataProject)'))))</_EfcptDataProjectPath>
    </PropertyGroup>

    <!-- Error if Data project not specified -->
    <Error Condition="'$(_EfcptDataProjectPath)' == ''"
           Text="EfcptSplitOutputs is enabled but EfcptDataProject is not set. Please specify the path to your Data project: &lt;EfcptDataProject&gt;..\MyProject.Data\MyProject.Data.csproj&lt;/EfcptDataProject&gt;" />

    <!-- Error if Data project doesn't exist -->
    <Error Condition="!Exists('$(_EfcptDataProjectPath)')"
           Text="EfcptDataProject was specified but the file does not exist: $(_EfcptDataProjectPath)" />

    <!-- Resolve Data project directory -->
    <PropertyGroup>
      <_EfcptDataProjectDir>$([System.IO.Path]::GetDirectoryName('$(_EfcptDataProjectPath)'))\</_EfcptDataProjectDir>
      <_EfcptDataDestDir>$(_EfcptDataProjectDir)$(EfcptDataProjectOutputSubdir)</_EfcptDataDestDir>
    </PropertyGroup>

    <Message Text="Split outputs enabled. DbContext and configurations will be copied to: $(_EfcptDataDestDir)" Importance="high" />
  </Target>

  <!--
    Copy generated DbContext and configuration files to the Data project.
    - DbContext files go to the root of the destination
    - Configuration files go to a Configurations subfolder
    - Files are deleted from the Models project after copying
    Only runs when source files exist (i.e., when generation actually occurred).
  -->
  <Target Name="EfcptCopyDataToDataProject"
          DependsOnTargets="EfcptValidateSplitOutputs"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' != 'true' and '$(EfcptSplitOutputs)' == 'true'">

    <!-- Find DbContext files (root-level .g.cs files that are NOT configurations) -->
    <ItemGroup>
      <_EfcptDbContextFiles Include="$(EfcptGeneratedDir)*.g.cs" Exclude="$(EfcptGeneratedDir)*Configuration.g.cs" />
    </ItemGroup>

    <!-- Find Configuration files (root-level *Configuration.g.cs or in Configurations folder) -->
    <ItemGroup>
      <_EfcptConfigurationFiles Include="$(EfcptGeneratedDir)*Configuration.g.cs" />
      <_EfcptConfigurationFiles Include="$(EfcptGeneratedDir)Configurations\**\*.g.cs" />
    </ItemGroup>

    <!-- Only proceed if there are source files to copy (generation occurred) -->
    <PropertyGroup>
      <_EfcptHasFilesToCopy Condition="'@(_EfcptDbContextFiles)' != '' or '@(_EfcptConfigurationFiles)' != ''">true</_EfcptHasFilesToCopy>
    </PropertyGroup>

    <!-- Clean destination directory first to remove stale files (only if we have files to copy) -->
    <RemoveDir Directories="$(_EfcptDataDestDir)" Condition="'$(_EfcptHasFilesToCopy)' == 'true' and Exists('$(_EfcptDataDestDir)')" />
    <MakeDir Directories="$(_EfcptDataDestDir)" Condition="'$(_EfcptHasFilesToCopy)' == 'true'" />
    <MakeDir Directories="$(_EfcptDataDestDir)Configurations" Condition="'@(_EfcptConfigurationFiles)' != ''" />

    <!-- Copy DbContext files to root of destination -->
    <Copy SourceFiles="@(_EfcptDbContextFiles)"
          DestinationFolder="$(_EfcptDataDestDir)"
          SkipUnchangedFiles="true"
          Condition="'@(_EfcptDbContextFiles)' != ''">
      <Output TaskParameter="CopiedFiles" ItemName="_EfcptCopiedDataFiles" />
    </Copy>

    <!-- Copy Configuration files to Configurations subfolder -->
    <Copy SourceFiles="@(_EfcptConfigurationFiles)"
          DestinationFolder="$(_EfcptDataDestDir)Configurations"
          SkipUnchangedFiles="true"
          Condition="'@(_EfcptConfigurationFiles)' != ''">
      <Output TaskParameter="CopiedFiles" ItemName="_EfcptCopiedDataFiles" />
    </Copy>

    <Message Text="Copied @(_EfcptCopiedDataFiles->Count()) data files to Data project: $(_EfcptDataDestDir)"
             Condition="'@(_EfcptCopiedDataFiles)' != ''"
             Importance="high" />

    <Message Text="Split outputs: No new files to copy (generation was skipped)"
             Condition="'$(_EfcptHasFilesToCopy)' != 'true'"
             Importance="normal" />

    <!-- Delete DbContext and Configuration files from Models project after copying -->
    <Delete Files="@(_EfcptDbContextFiles)" Condition="'@(_EfcptDbContextFiles)' != ''" />
    <Delete Files="@(_EfcptConfigurationFiles)" Condition="'@(_EfcptConfigurationFiles)' != ''" />
    <Message Text="Removed DbContext and configuration files from Models project"
             Condition="'$(_EfcptHasFilesToCopy)' == 'true'"
             Importance="normal" />
  </Target>

  <!--
    Include generated files in compilation.
    In split outputs mode (Models project), only include model files (from Models folder).
    In normal mode, include all generated files.
  -->
  <Target Name="EfcptAddToCompile"
          BeforeTargets="CoreCompile"
          DependsOnTargets="EfcptResolveInputs;EfcptUseDirectDacpac;EfcptEnsureDacpac;EfcptStageInputs;EfcptComputeFingerprint;EfcptGenerateModels;EfcptCopyDataToDataProject"
          Condition="'$(EfcptEnabled)' == 'true' and '$(_EfcptIsSqlProject)' != 'true'">
    <ItemGroup>
      <!-- In split outputs mode (Models project is primary), only include model files -->
      <Compile Include="$(EfcptGeneratedDir)Models\**\*.g.cs"
               Visible="false"
               Condition="'$(EfcptSplitOutputs)' == 'true'" />

      <!-- In normal mode, include all generated files -->
      <Compile Include="$(EfcptGeneratedDir)**\*.g.cs"
               Visible="false"
               Condition="'$(EfcptSplitOutputs)' != 'true'" />
    </ItemGroup>
  </Target>

  <!--
    Include external data files from another project (for Data project consumption).
    Used when Data project has EfcptEnabled=false but needs to compile copied DbContext/configs.
  -->
  <Target Name="EfcptIncludeExternalData"
          BeforeTargets="CoreCompile"
          Condition="'$(EfcptExternalDataDir)' != '' and Exists('$(EfcptExternalDataDir)')">
    <ItemGroup>
      <Compile Include="$(EfcptExternalDataDir)**\*.g.cs" Visible="false" />
    </ItemGroup>
    <Message Text="Including external data files from: $(EfcptExternalDataDir)" Importance="normal" />
  </Target>

  <!-- Clean target: remove efcpt output directory when 'dotnet clean' is run -->
  <Target Name="EfcptClean"
          AfterTargets="Clean"
          Condition="'$(EfcptEnabled)' == 'true'">
    <Message Text="Cleaning efcpt output: $(EfcptOutput)" Importance="normal" />
    <RemoveDir Directories="$(EfcptOutput)" Condition="Exists('$(EfcptOutput)')" />
  </Target>

  <!--
    Build Profiling: Finalize profiling at the end of the build pipeline.
    This target runs last to capture the complete build graph and write the profile to disk.
  -->
  <Target Name="_EfcptFinalizeProfiling"
          AfterTargets="Build"
          Condition="'$(EfcptEnabled)' == 'true' and '$(EfcptEnableProfiling)' == 'true'">
    <FinalizeBuildProfiling
        ProjectPath="$(MSBuildProjectFullPath)"
        OutputPath="$(EfcptProfilingOutput)"
        BuildSucceeded="true" />
  </Target>

</Project>
