using FluentAssertions;
using JD.MSBuild.Fluent.Generators;
using JD.MSBuild.Fluent.Typed;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace JD.MSBuild.Fluent.Tests;

public sealed class GeneratorSpecTests
{
  [Fact]
  public void Given_task_with_parameters_and_outputs_When_generator_runs_Then_emits_reference_and_parameter_types()
  {
    const string source = """
using JD.MSBuild.Fluent.Typed;

namespace Demo.Tasks
{
  [MsBuildTask(AssemblyFile = "$(_Tasks)")]
  public sealed class DoWork
  {
    public string Input { get; set; } = string.Empty;

    [Microsoft.Build.Framework.Output]
    public string Output { get; set; } = string.Empty;
  }
}

namespace Microsoft.Build.Framework
{
  [System.AttributeUsage(System.AttributeTargets.Property)]
  public sealed class OutputAttribute : System.Attribute
  {
  }
}
""";

    var generated = RunGenerator(source, assemblyName: "Demo.Tasks");

    const string expected = """
// MsBuildTask_DoWorkMsBuild.g.cs
// <auto-generated />
#nullable enable
using JD.MSBuild.Fluent.Typed;
using JD.MSBuild.Fluent.Fluent;

namespace Demo.Tasks
{
  public static class DoWorkMsBuild
  {
    public readonly struct TaskName : IMsBuildTaskName
    {
      public string Name => "Demo.Tasks.DoWork";
    }

    public static MsBuildTaskReference Reference => new MsBuildTaskReference("Demo.Tasks.DoWork", assemblyFile: "$(_Tasks)");

    public static class Parameters
    {
      public readonly struct Input : IMsBuildTaskParameterName
      {
        public string Name => "Input";
      }
      public readonly struct Output : IMsBuildTaskParameterName
      {
        public string Name => "Output";
      }
    }

    public static class Outputs
    {
      public readonly struct Output : IMsBuildTaskParameterName
      {
        public string Name => "Output";
      }
    }
  }
}

namespace Demo.Tasks.Extensions.DoWork
{
  public static class TaskInvocationExtensions
  {
    public static TaskInvocationBuilder Input(this TaskInvocationBuilder task, string value)
      => task.Param<global::Demo.Tasks.DoWorkMsBuild.Parameters.Input>(value);

    public static TaskInvocationBuilder Output(this TaskInvocationBuilder task, string value)
      => task.Param<global::Demo.Tasks.DoWorkMsBuild.Parameters.Output>(value);

    public static TaskInvocationBuilder OutputProperty<TProperty>(this TaskInvocationBuilder task, string? condition = null)
      where TProperty : IMsBuildPropertyName, new()
      => task.OutputProperty<global::Demo.Tasks.DoWorkMsBuild.Outputs.Output, TProperty>(condition);

    public static TaskInvocationBuilder OutputItem<TItem>(this TaskInvocationBuilder task, string? condition = null)
      where TItem : IMsBuildItemTypeName, new()
      => task.OutputItem<global::Demo.Tasks.DoWorkMsBuild.Outputs.Output, TItem>(condition);
  }
}
""";

    Normalize(generated).TrimEnd().Should().Be(Normalize(expected).TrimEnd());
  }

  [Fact]
  public void Given_task_with_name_style_and_ignore_When_generator_runs_Then_uses_short_name_and_skips_ignored()
  {
    const string source = """
using JD.MSBuild.Fluent.Typed;

namespace Spec.Tasks
{
  [MsBuildTask(NameStyle = MsBuildTaskNameStyle.Name, UseAssemblyName = true)]
  public sealed class BuildJob
  {
    public string Keep { get; set; } = string.Empty;

    [MsBuildIgnore]
    public string Skip { get; set; } = string.Empty;
  }
}
""";

    var generated = RunGenerator(source, assemblyName: "Spec.Assembly");

    Normalize(generated).Should().Contain("public string Name => \"BuildJob\";");
    Normalize(generated).Should().Contain("assemblyName: \"Spec.Assembly\"");
    Normalize(generated).Should().Contain("struct Keep");
    Normalize(generated).Should().NotContain("struct Skip");
  }

  private static string RunGenerator(string source, string assemblyName)
  {
    var syntaxTree = CSharpSyntaxTree.ParseText(source, new CSharpParseOptions(LanguageVersion.Latest));

    var references = new[]
    {
      MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
      MetadataReference.CreateFromFile(typeof(Enumerable).Assembly.Location),
      MetadataReference.CreateFromFile(typeof(System.Runtime.Versioning.TargetFrameworkAttribute).Assembly.Location),
      MetadataReference.CreateFromFile(typeof(MsBuildTaskAttribute).Assembly.Location)
    };

    var compilation = CSharpCompilation.Create(
      assemblyName,
      [syntaxTree],
      references,
      new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

    var generator = new MsBuildTaskGenerator();
    GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
    driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out _, out var diagnostics);

    diagnostics.Should().BeEmpty();

    var runResult = driver.GetRunResult();
    runResult.Diagnostics.Should().BeEmpty();

    var sources = runResult.Results.Single().GeneratedSources;
    return RenderSources(sources);
  }

  private static string RenderSources(IReadOnlyList<GeneratedSourceResult> sources)
  {
    return string.Join(
      "\n\n",
      sources
        .OrderBy(s => s.HintName, StringComparer.Ordinal)
        .Select(s => $"// {s.HintName}\n{s.SourceText}"));
  }

  private static string Normalize(string value) => value.Replace("\r\n", "\n");
}
