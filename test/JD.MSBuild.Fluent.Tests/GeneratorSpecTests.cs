using JD.MSBuild.Fluent.Generators;
using JD.MSBuild.Fluent.Typed;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using TinyBDD.Assertions;
using TinyBDD.Xunit;
using Xunit.Abstractions;

namespace JD.MSBuild.Fluent.Tests;

/// <summary>Feature: MsBuildTaskSourceGeneration</summary>
public sealed class GeneratorSpecTests(ITestOutputHelper output) : TinyBddXunitBase(output)
{
  [Fact]
  public async Task Given_task_with_parameters_and_outputs_When_generator_runs_Then_emits_reference_and_parameter_types()
  {
    const string source = """
using JD.MSBuild.Fluent.Typed;

namespace Demo.Tasks
{
  [MsBuildTask(AssemblyFile = "$(_Tasks)")]
  public sealed class DoWork
  {
    public string Input { get; set; } = string.Empty;

    [Microsoft.Build.Framework.Output]
    public string Output { get; set; } = string.Empty;
  }
}

namespace Microsoft.Build.Framework
{
  [System.AttributeUsage(System.AttributeTargets.Property)]
  public sealed class OutputAttribute : System.Attribute
  {
  }
}
""";

    const string expected = """
// MsBuildTask_DoWorkMsBuild.g.cs
// <auto-generated />
#nullable enable
using JD.MSBuild.Fluent.Typed;
using JD.MSBuild.Fluent.Fluent;

namespace Demo.Tasks
{
  public static class DoWorkMsBuild
  {
    public readonly struct TaskName : IMsBuildTaskName
    {
      public string Name => "Demo.Tasks.DoWork";
    }

    public static MsBuildTaskReference Reference => new MsBuildTaskReference("Demo.Tasks.DoWork", assemblyFile: "$(_Tasks)");

    public static class Parameters
    {
      public readonly struct Input : IMsBuildTaskParameterName
      {
        public string Name => "Input";
      }
      public readonly struct Output : IMsBuildTaskParameterName
      {
        public string Name => "Output";
      }
    }

    public static class Outputs
    {
      public readonly struct Output : IMsBuildTaskParameterName
      {
        public string Name => "Output";
      }
    }
  }
}

namespace Demo.Tasks.Extensions.DoWork
{
  public static class TaskInvocationExtensions
  {
    public static TaskInvocationBuilder Input(this TaskInvocationBuilder task, string value)
      => task.Param<global::Demo.Tasks.DoWorkMsBuild.Parameters.Input>(value);

    public static TaskInvocationBuilder Output(this TaskInvocationBuilder task, string value)
      => task.Param<global::Demo.Tasks.DoWorkMsBuild.Parameters.Output>(value);

    public static TaskInvocationBuilder OutputProperty<TProperty>(this TaskInvocationBuilder task, string? condition = null)
      where TProperty : IMsBuildPropertyName, new()
      => task.OutputProperty<global::Demo.Tasks.DoWorkMsBuild.Outputs.Output, TProperty>(condition);

    public static TaskInvocationBuilder OutputItem<TItem>(this TaskInvocationBuilder task, string? condition = null)
      where TItem : IMsBuildItemTypeName, new()
      => task.OutputItem<global::Demo.Tasks.DoWorkMsBuild.Outputs.Output, TItem>(condition);
  }
}
""";

    await Given("task source with parameters and outputs", () => source)
      .When("running source generator", src => RunGenerator(src, assemblyName: "Demo.Tasks"))
      .Then("generated code matches expected", generated =>
        Expect.For(Normalize(generated).TrimEnd(), "generated code")
          .ToBe(Normalize(expected).TrimEnd()))
      .AssertPassed();
  }

  [Fact]
  public async Task Given_task_with_name_style_and_ignore_When_generator_runs_Then_uses_short_name_and_skips_ignored()
  {
    const string source = """
using JD.MSBuild.Fluent.Typed;

namespace Spec.Tasks
{
  [MsBuildTask(NameStyle = MsBuildTaskNameStyle.Name, UseAssemblyName = true)]
  public sealed class BuildJob
  {
    public string Keep { get; set; } = string.Empty;

    [MsBuildIgnore]
    public string Skip { get; set; } = string.Empty;
  }
}
""";

    await Given("task source with name style and ignore attribute", () => source)
      .When("running source generator", src => RunGenerator(src, assemblyName: "Spec.Assembly"))
      .Then("uses short name", generated =>
        Expect.That(Normalize(generated), "generated code").ToSatisfy(code => code.Contains("public string Name => \"BuildJob\";"), "contain short name"))
      .And("includes assembly name", generated =>
        Expect.That(Normalize(generated), "generated code").ToSatisfy(code => code.Contains("assemblyName: \"Spec.Assembly\""), "contain assembly name"))
      .And("includes kept property", generated =>
        Expect.That(Normalize(generated), "generated code").ToSatisfy(code => code.Contains("struct Keep"), "contain kept property"))
      .But("excludes ignored property", generated =>
        Expect.That(Normalize(generated), "generated code").ToSatisfy(code => !code.Contains("struct Skip"), "not contain ignored property"))
      .AssertPassed();
  }

  #region Helpers

  private static string RunGenerator(string source, string assemblyName)
  {
    var syntaxTree = CSharpSyntaxTree.ParseText(source, new CSharpParseOptions(LanguageVersion.Latest));

    var references = new[]
    {
      MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
      MetadataReference.CreateFromFile(typeof(Enumerable).Assembly.Location),
      MetadataReference.CreateFromFile(typeof(System.Runtime.Versioning.TargetFrameworkAttribute).Assembly.Location),
      MetadataReference.CreateFromFile(typeof(MsBuildTaskAttribute).Assembly.Location)
    };

    var compilation = CSharpCompilation.Create(
      assemblyName,
      [syntaxTree],
      references,
      new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

    var generator = new MsBuildTaskGenerator();
    GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
    driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out _, out var diagnostics);

    Assert.Empty(diagnostics);

    var runResult = driver.GetRunResult();
    Assert.Empty(runResult.Diagnostics);

    var sources = runResult.Results.Single().GeneratedSources;
    return RenderSources(sources);
  }

  private static string RenderSources(IReadOnlyList<GeneratedSourceResult> sources)
  {
    return string.Join(
      "\n\n",
      sources
        .OrderBy(s => s.HintName, StringComparer.Ordinal)
        .Select(s => $"// {s.HintName}\n{s.SourceText}"));
  }

  private static string Normalize(string value) => value.Replace("\r\n", "\n");

  #endregion
}
